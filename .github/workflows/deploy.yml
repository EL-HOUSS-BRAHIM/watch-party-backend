name: Deploy Watch Party Backend

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment'
        required: false
        default: false
        type: boolean

# Principle of least privilege for GHA token
permissions:
  contents: read
  id-token: write  # (Reserved if later switching to OIDC-based secrets/infra auth)
  actions: read
  checks: read

# Prevent overlapping deployments on same branch
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: '3.12'

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    if: >-
      (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event.inputs.force_deploy == 'true') && github.event_name != 'pull_request'
    outputs:
      deployment_ready: ${{ steps.check_deployment.outputs.ready }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up Python (for validation / lock)
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'
          cache-dependency-path: requirements.txt
      - name: Validate workflow inputs
        id: validate
        run: |
          echo "force_deploy=${{ github.event.inputs.force_deploy || 'false' }}"
      - name: Check deployment readiness
        id: check_deployment
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/master" || "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "ready=true" >> $GITHUB_OUTPUT
          else
            echo "ready=false" >> $GITHUB_OUTPUT
          fi
      - name: Freeze dependencies (for traceability)
        if: steps.check_deployment.outputs.ready == 'true'
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip freeze > requirements.freeze.txt
      - name: Create deployment package
        if: steps.check_deployment.outputs.ready == 'true'
        run: |
          mkdir -p deployment-package
          rsync -av --exclude='.git' \
                    --exclude='*.pyc' \
                    --exclude='__pycache__' \
                    --exclude='.pytest_cache' \
                    --exclude='node_modules' \
                    --exclude='.env' \
                    --exclude='db.sqlite3' \
                    --exclude='logs' \
                    --exclude='.coverage' \
                    --exclude='htmlcov' \
                    --exclude='*.log' \
                    --exclude='.vscode' \
                    --exclude='.idea' \
                    ./ deployment-package/
          # Copy optional env/example files only if present
          for f in .env.example .env.production; do
            if [[ -f "$f" ]]; then
              cp "$f" deployment-package/
            else
              echo "$f not found, skipping"
            fi
          done
          cp requirements.freeze.txt deployment-package/ 2>/dev/null || true
          if [[ -f .env ]]; then
            grep -Ev '^(SECRET_KEY=|DATABASE_URL=postgresql://watchparty_admin:|REDIS_URL=rediss://|DATABASE_PASSWORD=|REDIS_PASSWORD=)' .env > deployment-package/.env.template || true
          fi
          cat > deployment-package/deployment-info.json <<'JSON'
          {
            "commit_sha": "${{ github.sha }}",
            "commit_message": "$(echo "$(git log -1 --pretty=%B | head -1)" | sed 's/"/\\"/g')",
            "branch": "${{ github.ref_name }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "actor": "${{ github.actor }}",
            "run_id": "${{ github.run_id }}"
          }
          JSON
      - name: Generate checksums
        if: steps.check_deployment.outputs.ready == 'true'
        run: |
          # Recreate checksum file deterministically; exclude itself & CI/meta files
          (cd deployment-package && \
            rm -f CHECKSUMS.sha256 && \
            find . -type f -maxdepth 8 \
              ! -name 'CHECKSUMS.sha256' \
              ! -path './.github/*' \
              ! -path './logs/*' \
              ! -path './**/__pycache__/*' \
              ! -name '*.pyc' \
              -print0 | sort -z | xargs -0 sha256sum > CHECKSUMS.sha256)
      - name: Upload deployment package
        if: steps.check_deployment.outputs.ready == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: deployment-package/
          retention-days: 30

  deploy:
    needs: [build]
    runs-on: ubuntu-latest
    timeout-minutes: 30
    if: needs.build.outputs.deployment_ready == 'true'
    environment: production
    steps:
      - name: Checkout code (for remote script)
        uses: actions/checkout@v4
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package
          path: deployment-package/
      - name: Verify checksums
        run: |
          cd deployment-package
          if [[ ! -f CHECKSUMS.sha256 ]]; then
            echo "No checksum file present, skipping verification"
            exit 0
          fi
          # Filter out any entries whose files are absent (e.g., intentionally excluded on deploy)
          TMP_FILE=$(mktemp)
          while read -r hash path; do
            # path comes like: <hash><space><space>./relative
            file=${path#./}
            if [[ -f "$file" ]]; then
              printf '%s  %s\n' "$hash" "$path" >> "$TMP_FILE"
            else
              echo "Skipping missing $path"
            fi
          done < CHECKSUMS.sha256
          if [[ ! -s "$TMP_FILE" ]]; then
            echo "No files left to verify; skipping"
            exit 0
          fi
          sha256sum -c "$TMP_FILE" || { echo "Checksum mismatch(s) detected"; exit 1; }
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
      - name: Generate production .env (sanitized) locally
        env:
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
          CSRF_TRUSTED_ORIGINS: ${{ secrets.CSRF_TRUSTED_ORIGINS }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          CELERY_BROKER_URL: ${{ secrets.CELERY_BROKER_URL }}
          CELERY_RESULT_BACKEND: ${{ secrets.CELERY_RESULT_BACKEND }}
          CHANNEL_LAYERS_CONFIG_HOSTS: ${{ secrets.CHANNEL_LAYERS_CONFIG_HOSTS }}
          DEFAULT_FROM_EMAIL: ${{ secrets.DEFAULT_FROM_EMAIL }}
        run: |
          OUT=deployment-package/.env.generated
          : > "$OUT"
          echo "SECRET_KEY=$SECRET_KEY" >> "$OUT"
          echo "DJANGO_SETTINGS_MODULE=watchparty.settings.production" >> "$OUT"
          echo "ALLOWED_HOSTS=$ALLOWED_HOSTS" >> "$OUT"
          echo "CSRF_TRUSTED_ORIGINS=$CSRF_TRUSTED_ORIGINS" >> "$OUT"
          echo "DATABASE_URL=$DATABASE_URL" >> "$OUT"
          echo "REDIS_URL=$REDIS_URL" >> "$OUT"
          echo "CELERY_BROKER_URL=$CELERY_BROKER_URL" >> "$OUT"
          echo "CELERY_RESULT_BACKEND=$CELERY_RESULT_BACKEND" >> "$OUT"
          echo "CHANNEL_LAYERS_CONFIG_HOSTS=$CHANNEL_LAYERS_CONFIG_HOSTS" >> "$OUT"
          echo "DEFAULT_FROM_EMAIL=$DEFAULT_FROM_EMAIL" >> "$OUT"
          if [[ -n "${SENTRY_DSN:-}" ]]; then echo "SENTRY_DSN=$SENTRY_DSN" >> "$OUT"; fi
          echo "ENVIRONMENT=production" >> "$OUT"
          echo "DEBUG=False" >> "$OUT"
          echo "RATE_LIMIT_ENABLED=True" >> "$OUT"
          echo "‚úÖ Generated .env.generated with $(wc -l < "$OUT") environment variables"
          ls -la deployment-package/.env.generated
      - name: Prepare remote deploy script
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          cat > ci_remote_deploy.sh << 'SCRIPT'
          #!/bin/bash
          set -euo pipefail
          umask 022

          DEPLOY_DIR="${DEPLOY_DIR:-/var/www/watch-party-backend}"
          SERVICE_USER="${SERVER_USER:-www-data}"
          SERVICE_GROUP="www-data"

          echo "$(date): üîß Starting server environment setup..."
          echo "Deploy directory: $DEPLOY_DIR"
          echo "Service user: $SERVICE_USER"

          # Detect package manager
          if command -v apt-get >/dev/null 2>&1; then
            sudo apt-get update -qq || true
            INSTALLER="apt-get install -y"
          elif command -v yum >/dev/null 2>&1; then
            sudo yum -y -q update || true
            INSTALLER="yum install -y"
          elif command -v dnf >/dev/null 2>&1; then
            sudo dnf -y -q update || true
            INSTALLER="dnf install -y"
          else
            echo "Unsupported package manager"; exit 1
          fi

          echo "Installing base packages (idempotent)"
          if command -v apt-get >/dev/null 2>&1; then
            sudo apt-get install -y python3 python3-venv python3-pip python3-dev build-essential libpq-dev rsync curl git netcat-traditional || true
          else
            sudo $INSTALLER python3 python3-pip rsync curl git netcat || true
          fi

          # Increase system limits for the deployment
          echo "Configuring system limits..."
          echo "* soft nofile 65536" | sudo tee -a /etc/security/limits.conf >/dev/null || true
          echo "* hard nofile 65536" | sudo tee -a /etc/security/limits.conf >/dev/null || true
          
          # Set current session limits
          ulimit -n 65536 2>/dev/null || true

          # Create service user if missing
          if ! id "$SERVICE_USER" >/dev/null 2>&1; then
            sudo useradd -r -s /usr/sbin/nologin -d /var/www -c "WatchParty Service User" "$SERVICE_USER" || true
          fi

          # Directory setup & ownership BEFORE rsync
          sudo mkdir -p "$DEPLOY_DIR" /var/log/watchparty
          sudo chown -R $SERVICE_USER:$SERVICE_GROUP "$DEPLOY_DIR" /var/log/watchparty

          echo "üì§ Syncing project files to $DEPLOY_DIR";
          sudo rsync -av --delete --exclude='venv' --exclude='.env' --exclude='.env.generated' --chown=$SERVICE_USER:$SERVICE_GROUP ./ "$DEPLOY_DIR/"

          # Ensure application log directory exists AFTER rsync (matching Django settings)
          sudo mkdir -p /var/log/watchparty "$DEPLOY_DIR/logs"
          sudo touch /var/log/watchparty/django.log
          sudo touch /var/log/watchparty/django_errors.log
          sudo touch /var/log/watchparty/access.log
          sudo touch /var/log/watchparty/error.log
          # Create project-level logs as backup (base settings reference)
          sudo touch "$DEPLOY_DIR/logs/django.log"
          sudo touch "$DEPLOY_DIR/logs/security.log"
          sudo touch "$DEPLOY_DIR/logs/performance.log"
          # Create symlinks for backward compatibility
          sudo ln -sf /var/log/watchparty/django.log "$DEPLOY_DIR/logs/django_main.log" 2>/dev/null || true
          sudo chown -R $SERVICE_USER:$SERVICE_GROUP /var/log/watchparty "$DEPLOY_DIR/logs"
          sudo chmod 664 /var/log/watchparty/django.log /var/log/watchparty/django_errors.log /var/log/watchparty/access.log /var/log/watchparty/error.log || true
          sudo chmod 664 "$DEPLOY_DIR/logs/django.log" "$DEPLOY_DIR/logs/security.log" "$DEPLOY_DIR/logs/performance.log" || true

          # Handle environment file - CRITICAL for service startup
          echo "üîß Setting up environment file..."
          ENV_FILE=""
          if [[ -f ./.env.generated ]]; then
            echo "Found .env.generated, using it"
            ENV_FILE="./.env.generated"
          elif [[ -f ./.env.production ]]; then
            echo "Found .env.production, using it as fallback"  
            ENV_FILE="./.env.production"
          elif [[ -f ./.env.example ]]; then
            echo "Found .env.example, using it as last resort"
            ENV_FILE="./.env.example"
          else
            echo "‚ùå No environment file found - this is a critical error"
            echo "Available files in current directory:"
            ls -la || true
            exit 1
          fi
          
          echo "Using environment file: $ENV_FILE"
          sudo cp "$ENV_FILE" "$DEPLOY_DIR/.env"
          sudo chmod 600 "$DEPLOY_DIR/.env"
          sudo chown $SERVICE_USER:$SERVICE_GROUP "$DEPLOY_DIR/.env"
          echo "‚úÖ Environment file placed successfully from $ENV_FILE"

          cd "$DEPLOY_DIR"
          echo "üîß Ensuring clean & writable virtual environment"
          if [[ -d venv ]]; then
            OWNER=$(stat -c %U venv || echo unknown)
            if [[ "$OWNER" != "$SERVICE_USER" ]]; then
              echo "Existing venv owned by $OWNER; removing with sudo"
              sudo rm -rf venv || { echo "Failed to remove existing venv"; exit 1; }
            elif [[ ! -w venv/bin/python* ]]; then
              echo "Existing venv not writable; removing"
              sudo rm -rf venv || { echo "Failed to remove unwritable venv"; exit 1; }
            fi
          fi
          if [[ -d venv && ! -f venv/bin/activate ]]; then
            echo "Corrupted venv detected; removing"
            sudo rm -rf venv || { echo "Failed to remove corrupted venv"; exit 1; }
          fi
          if [[ ! -d venv ]]; then
            echo "Creating venv as $SERVICE_USER"
            sudo -u $SERVICE_USER -H python3 -m venv venv || { echo "Failed to create venv"; exit 1; }
          fi
          sudo chown -R $SERVICE_USER:$SERVICE_GROUP venv || true
          sudo chmod -R u+w venv || true
          # Verify site-packages writable; attempt auto-fix once if not
          if ! sudo -u $SERVICE_USER -H python3 -c "import sys,os,pathlib; sp=[p for p in sys.path if p.endswith('site-packages')]; sp=sp[0] if sp else ''; print('Site-packages:', sp); (pathlib.Path(sp)/'__perm_test__').write_text('ok') if sp else None"; then
            echo "Attempting permission repair on venv..."
            sudo chown -R $SERVICE_USER:$SERVICE_GROUP venv || true
            sudo chmod -R u+rwX venv || true
            sudo -u $SERVICE_USER -H python3 -c "import sys,os,pathlib; sp=[p for p in sys.path if p.endswith('site-packages')]; sp=sp[0] if sp else ''; print('Recheck Site-packages:', sp); (pathlib.Path(sp)/'__perm_test__').write_text('ok') if sp else None" || { echo "site-packages still not writable for $SERVICE_USER"; ls -ld venv/lib/python*/site-packages || true; exit 1; }
          fi

          echo "üì¶ Installing Python dependencies as $SERVICE_USER"
          sudo -u $SERVICE_USER -H bash -c 'source venv/bin/activate && python -m ensurepip --upgrade || true && pip install --upgrade pip setuptools wheel && pip install -r requirements.txt && pip install gunicorn gevent'

          echo "üóÑ Running migrations & collectstatic"
          # Ensure logs directory exists before Django operations (matching Django settings)
          sudo mkdir -p /var/log/watchparty "$DEPLOY_DIR/logs"
          sudo touch /var/log/watchparty/django.log
          sudo touch /var/log/watchparty/django_errors.log
          sudo touch /var/log/watchparty/access.log
          sudo touch /var/log/watchparty/error.log
          # Create project-level logs as backup (base settings reference)
          sudo touch "$DEPLOY_DIR/logs/django.log"
          sudo touch "$DEPLOY_DIR/logs/security.log"
          sudo touch "$DEPLOY_DIR/logs/performance.log"
          sudo chown -R $SERVICE_USER:$SERVICE_GROUP /var/log/watchparty "$DEPLOY_DIR/logs"
          sudo chmod 664 /var/log/watchparty/django.log /var/log/watchparty/django_errors.log /var/log/watchparty/access.log /var/log/watchparty/error.log || true
          sudo chmod 664 "$DEPLOY_DIR/logs/django.log" "$DEPLOY_DIR/logs/security.log" "$DEPLOY_DIR/logs/performance.log" || true
          sudo -u $SERVICE_USER -H bash -c 'source venv/bin/activate && python manage.py migrate --noinput || true && python manage.py collectstatic --noinput || true'

          # Pre-deployment diagnostics and cleanup
          echo "üîç Running pre-deployment diagnostics..."
          
          # Check for port conflicts
          if sudo lsof -i :8000 >/dev/null 2>&1; then
            echo "Port 8000 is in use. Identifying and stopping conflicting processes..."
            sudo lsof -i :8000 || true
            # Kill any processes using port 8000
            sudo fuser -k 8000/tcp 2>/dev/null || true
            sleep 2
          fi
          
          # Check system resources
          echo "System memory: $(free -h | grep 'Mem:' | awk '{print $2 " total, " $7 " available"}')"
          echo "Disk space: $(df -h $DEPLOY_DIR | tail -1 | awk '{print $4 " available"}')"
          echo "Open file limit: $(ulimit -n)"
          
          # Stop existing service gracefully
          if sudo systemctl is-active --quiet watchparty-gunicorn 2>/dev/null; then
            echo "Stopping existing Gunicorn service..."
            sudo systemctl stop watchparty-gunicorn || true
            sleep 3
          fi
          
          # Systemd service creation (idempotent)
          if [[ ! -f /etc/systemd/system/watchparty-gunicorn.service ]]; then
            cat > /tmp/watchparty-gunicorn.service << EOF
          [Unit]
          Description=Watch Party Gunicorn Application Server
          After=network.target
          Wants=network-online.target
          After=network-online.target

          [Service]
          Type=notify
          User=$SERVICE_USER
          Group=$SERVICE_GROUP
          WorkingDirectory=$DEPLOY_DIR
          EnvironmentFile=$DEPLOY_DIR/.env
          Environment=PYTHONPATH=$DEPLOY_DIR
          Environment=PATH=$DEPLOY_DIR/venv/bin:/usr/local/bin:/usr/bin:/bin
          
          # Resource limits
          LimitNOFILE=65536
          LimitNPROC=4096
          MemoryMax=1G
          
          # Pre-start checks
          ExecStartPre=/bin/bash -c 'test -f $DEPLOY_DIR/.env || (echo ".env file missing" && exit 1)'
          ExecStartPre=/bin/bash -c 'test -f $DEPLOY_DIR/venv/bin/gunicorn || (echo "Gunicorn binary missing" && exit 1)'
          ExecStartPre=/bin/bash -c 'test -d /var/log/watchparty || mkdir -p /var/log/watchparty'
          ExecStartPre=/bin/bash -c 'chown -R $SERVICE_USER:$SERVICE_GROUP /var/log/watchparty'
          
          # Main service command
          ExecStart=$DEPLOY_DIR/venv/bin/gunicorn \\
              --bind 127.0.0.1:8000 \\
              --workers 2 \\
              --worker-class gevent \\
              --worker-connections 1000 \\
              --max-requests 1000 \\
              --timeout 30 \\
              --keep-alive 5 \\
              --access-logfile /var/log/watchparty/access.log \\
              --error-logfile /var/log/watchparty/error.log \\
              --log-level info \\
              --preload \\
              watchparty.wsgi:application
          
          # Process management
          ExecReload=/bin/kill -s HUP \$MAINPID
          KillMode=mixed
          KillSignal=SIGTERM
          TimeoutStartSec=60
          TimeoutStopSec=30
          Restart=on-failure
          RestartSec=10
          
          # Security settings
          NoNewPrivileges=true
          PrivateTmp=true
          ProtectSystem=strict
          ReadWritePaths=$DEPLOY_DIR /var/log/watchparty /tmp
          ProtectHome=true

          [Install]
          WantedBy=multi-user.target
          EOF
            sudo mv /tmp/watchparty-gunicorn.service /etc/systemd/system/watchparty-gunicorn.service
            sudo systemctl daemon-reload
            sudo systemctl enable watchparty-gunicorn
          fi

          # Final check - ensure all dependencies are in place before starting service
          echo "üîß Final pre-start verification..."
          sudo mkdir -p /var/log/watchparty "$DEPLOY_DIR/logs"
          sudo touch /var/log/watchparty/django.log
          sudo touch /var/log/watchparty/django_errors.log
          sudo touch /var/log/watchparty/access.log
          sudo touch /var/log/watchparty/error.log
          # Create project-level logs as backup (base settings reference)
          sudo touch "$DEPLOY_DIR/logs/django.log"
          sudo touch "$DEPLOY_DIR/logs/security.log"
          sudo touch "$DEPLOY_DIR/logs/performance.log"
          sudo chown -R $SERVICE_USER:$SERVICE_GROUP /var/log/watchparty "$DEPLOY_DIR/logs"
          sudo chmod 664 /var/log/watchparty/django.log /var/log/watchparty/django_errors.log /var/log/watchparty/access.log /var/log/watchparty/error.log || true
          sudo chmod 664 "$DEPLOY_DIR/logs/django.log" "$DEPLOY_DIR/logs/security.log" "$DEPLOY_DIR/logs/performance.log" || true

          # Verify critical files exist
          if [[ ! -f "$DEPLOY_DIR/.env" ]]; then
            echo "‚ùå .env file missing - cannot start service"
            exit 1
          fi
          
          if [[ ! -f "$DEPLOY_DIR/venv/bin/gunicorn" ]]; then
            echo "‚ùå Gunicorn binary missing - cannot start service"
            exit 1
          fi
          
          # Test Python environment
          echo "üêç Testing Python environment..."
          sudo -u $SERVICE_USER -H bash -c "cd $DEPLOY_DIR && source venv/bin/activate && python -c 'import django; print(f\"Django version: {django.get_version()}\")'" || {
            echo "‚ùå Python environment test failed"
            exit 1
          }
          
          # Test Django configuration
          echo "üîß Testing Django configuration..."
          sudo -u $SERVICE_USER -H bash -c "cd $DEPLOY_DIR && source venv/bin/activate && python manage.py check --deploy" || {
            echo "‚ùå Django configuration check failed"
            # Don't exit - this might be non-critical
          }

          # Start the service with comprehensive error handling
          echo "üöÄ Starting Gunicorn service..."
          if sudo systemctl start watchparty-gunicorn; then
            echo "‚úÖ Service start command succeeded"
            
            # Wait for service to stabilize
            sleep 10
            
            # Check service status
            if sudo systemctl is-active --quiet watchparty-gunicorn; then
              echo "‚úÖ Gunicorn service is running"
            else
              echo "‚ùå Service failed to start properly"
              sudo systemctl status watchparty-gunicorn --no-pager -l || true
              sudo journalctl -xeu watchparty-gunicorn --no-pager -l || true
              exit 1
            fi
            
            # Test port binding
            if ss -tlnp | grep :8000 >/dev/null; then
              echo "‚úÖ Service is listening on port 8000"
            else
              echo "‚ùå Service is not listening on port 8000"
              exit 1
            fi
          else
            echo "‚ùå Service start command failed"
            sudo systemctl status watchparty-gunicorn --no-pager -l || true
            sudo journalctl -xeu watchparty-gunicorn --no-pager -l || true
            exit 1
          fi

          echo "Health check"
          # Give the application time to fully initialize
          sleep 5
          if curl -f -m 10 http://127.0.0.1:8000/health/ >/dev/null 2>&1; then
            echo "‚úÖ Application health check passed"
          else
            echo "‚ùå Application health check failed"
            # Don't exit here - the service might be starting slowly
          fi
          SCRIPT
          chmod +x ci_remote_deploy.sh
      - name: Deploy to server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          PROJECT_DIR: ${{ secrets.PROJECT_DIR }}
        timeout-minutes: 30
        run: |
          FALLBACK_DIR="/var/www/watch-party-backend"
          TARGET_DIR="${PROJECT_DIR:-$FALLBACK_DIR}"
          
          echo "üöÄ Starting deployment to $SERVER_HOST..."
          echo "Target directory: $TARGET_DIR"
          
          # Test SSH connection first
          echo "üîó Testing SSH connection..."
          if ! ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "echo 'SSH connection successful'"; then
            echo "‚ùå SSH connection failed"
            exit 1
          fi
          
          # Clean up and prepare remote directory
          echo "üßπ Preparing remote directory..."
          ssh $SERVER_USER@$SERVER_HOST "rm -rf /tmp/watchparty-deploy && mkdir -p /tmp/watchparty-deploy"
          
          # Upload files with progress
          echo "üì§ Uploading deployment files..."
          echo "Files being uploaded:"
          ls -la deployment-package/
          echo "Checking for .env.generated specifically:"
          ls -la deployment-package/.env.generated || echo ".env.generated not found in deployment-package"
          scp -o StrictHostKeyChecking=no -r deployment-package/* $SERVER_USER@$SERVER_HOST:/tmp/watchparty-deploy/
          # Ensure .env.generated is uploaded separately if it exists
          if [[ -f deployment-package/.env.generated ]]; then
            echo "üì§ Explicitly uploading .env.generated..."
            scp -o StrictHostKeyChecking=no deployment-package/.env.generated $SERVER_USER@$SERVER_HOST:/tmp/watchparty-deploy/
          fi
          scp -o StrictHostKeyChecking=no ci_remote_deploy.sh $SERVER_USER@$SERVER_HOST:/tmp/watchparty-deploy/
          
          # Execute deployment with timeout
          echo "‚öôÔ∏è Executing remote deployment script..."
          ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "
            cd /tmp/watchparty-deploy
            echo 'üìã Files received on server:'
            ls -la
            echo 'üìã Checking for environment files:'
            echo 'Looking for .env.generated:'
            if [[ -f .env.generated ]]; then
              echo '‚úÖ .env.generated found with $(wc -l < .env.generated) lines'
              echo 'First few lines (sanitized):'
              head -3 .env.generated | sed 's/=.*/=***/' || true
            else
              echo '‚ùå .env.generated not found!'
            fi
            echo 'Looking for other env files:'
            ls -la .env* 2>/dev/null || echo 'No .env* files found'
            timeout 1200 bash -x ./ci_remote_deploy.sh
          " || {
            echo "‚ùå Deployment script failed or timed out"
            echo "üîç Checking for any error logs..."
            ssh $SERVER_USER@$SERVER_HOST "tail -50 /var/log/watchparty/error.log 2>/dev/null || echo 'No Gunicorn error log found yet'; tail -50 /var/log/watchparty/django_errors.log 2>/dev/null || echo 'No Django error log found yet'"
            exit 1
          }
          
          echo "‚úÖ Remote deployment completed successfully"
      - name: Post-deployment verification
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          echo "üîç Running post-deployment verification..."
          
          # Wait a moment for services to stabilize
          sleep 10
          
          # Check service status with comprehensive diagnostics
          echo "Checking systemd services..."
          ssh $SERVER_USER@$SERVER_HOST "
            echo '=== Gunicorn Service Status ==='
            sudo systemctl status watchparty-gunicorn --no-pager -l || true
            echo
            echo '=== Service Process Info ==='
            if sudo systemctl is-active --quiet watchparty-gunicorn; then
              PID=\$(sudo systemctl show watchparty-gunicorn --property=MainPID --value)
              if [[ \"\$PID\" != \"0\" ]]; then
                echo \"Main PID: \$PID\"
                ps -p \"\$PID\" -o pid,ppid,user,cmd || true
                echo \"Process listening on ports:\"
                ss -tlnp | grep \"\$PID\" || echo 'No ports found for this PID'
              fi
            else
              echo 'Service is not active'
            fi
            echo
            echo '=== Port 8000 Status ==='
            if ss -tlnp | grep :8000; then
              echo 'Port 8000 is in use'
            else
              echo 'Port 8000 is not in use'
            fi
            echo
            echo '=== Recent Service Logs ==='
            sudo journalctl -u watchparty-gunicorn --no-pager -n 20 || true
            echo
            echo '=== Application Logs ==='
            tail -10 /var/log/watchparty/error.log 2>/dev/null || echo 'No Gunicorn error log found'
            tail -10 /var/log/watchparty/access.log 2>/dev/null || echo 'No Gunicorn access log found'
            tail -10 /var/log/watchparty/django_errors.log 2>/dev/null || echo 'No Django error log found'
            echo '=== Project-level logs (backup) ==='
            tail -5 /var/www/watch-party-backend/logs/django.log 2>/dev/null || echo 'No project-level Django log found'
            echo
            echo '=== System Resources ==='
            echo \"Memory: \$(free -h | grep 'Mem:' | awk '{print \$7 \" available of \" \$2}')\"
            echo \"Disk: \$(df -h /var/www/watch-party-backend | tail -1 | awk '{print \$4 \" available\"}')\\"
            echo \"Load: \$(uptime | awk -F'load average:' '{print \$2}')\"
            echo
            echo '=== Nginx Service Status ==='
            sudo systemctl status nginx --no-pager -l || true
          "
          
          # Test endpoints with detailed error reporting
          echo "Testing application endpoints..."
          
          # Test direct application
          if ssh $SERVER_USER@$SERVER_HOST "curl -f -m 15 -w 'HTTP %{http_code} in %{time_total}s\n' http://127.0.0.1:8000/health/ >/dev/null 2>&1"; then
            echo "‚úÖ Direct application health check passed"
          else
            echo "‚ö†Ô∏è Direct application health check failed"
            ssh $SERVER_USER@$SERVER_HOST "
              echo 'Attempting detailed health check...'
              curl -v -m 15 http://127.0.0.1:8000/health/ 2>&1 || true
              echo
              echo 'Checking if anything is listening on port 8000:'
              ss -tlnp | grep :8000 || echo 'Nothing listening on port 8000'
            "
          fi
          
          # Test through nginx proxy
          if ssh $SERVER_USER@$SERVER_HOST "curl -f -m 15 -w 'HTTP %{http_code} in %{time_total}s\n' http://127.0.0.1/health/ >/dev/null 2>&1"; then
            echo "‚úÖ Nginx proxy health check passed"
          else
            echo "‚ö†Ô∏è Nginx proxy health check failed"
            ssh $SERVER_USER@$SERVER_HOST "
              echo 'Checking Nginx configuration...'
              sudo nginx -t || true
              echo 'Checking Nginx error logs...'
              tail -10 /var/log/nginx/error.log 2>/dev/null || echo 'No Nginx error log found'
            "
          fi
          
          # Run diagnostic script if service failed
          ssh $SERVER_USER@$SERVER_HOST "
            if ! sudo systemctl is-active --quiet watchparty-gunicorn; then
              echo '=== Running Gunicorn Diagnostics ==='
              if [[ -f /var/www/watch-party-backend/scripts/diagnose-gunicorn.sh ]]; then
                sudo /var/www/watch-party-backend/scripts/diagnose-gunicorn.sh 2>&1 | head -100
              else
                echo 'Diagnostic script not found'
              fi
            fi
          "
      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment completed successfully"
          else
            echo "‚ùå Deployment failed"
          fi
  cleanup:
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Cleanup
        run: |
          echo "Workflow finished for commit ${{ github.sha }}"
