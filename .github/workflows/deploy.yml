name: Deploy Watch Party Backend

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment'
        required: false
        default: false
        type: boolean

env:
  PYTHON_VERSION: '3.12'

jobs:
  build:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master' || github.event.inputs.force_deploy == 'true'
    outputs:
      deployment_ready: ${{ steps.check_deployment.outputs.ready }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Check deployment readiness
        id: check_deployment
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" || "${{ github.ref }}" == "refs/heads/master" || "${{ github.event.inputs.force_deploy }}" == "true" ]]; then
            echo "ready=true" >> $GITHUB_OUTPUT
          else
            echo "ready=false" >> $GITHUB_OUTPUT
          fi
      - name: Create deployment package
        if: steps.check_deployment.outputs.ready == 'true'
        run: |
          mkdir -p deployment-package
          rsync -av --exclude='.git' \
                    --exclude='*.pyc' \
                    --exclude='__pycache__' \
                    --exclude='.pytest_cache' \
                    --exclude='node_modules' \
                    --exclude='.env' \
                    --exclude='db.sqlite3' \
                    --exclude='logs' \
                    --exclude='.coverage' \
                    --exclude='htmlcov' \
                    --exclude='*.log' \
                    --exclude='.vscode' \
                    --exclude='.idea' \
                    ./ deployment-package/
          if [[ -f .env ]]; then
            grep -Ev '^(SECRET_KEY=|DATABASE_URL=postgresql://watchparty_admin:|REDIS_URL=rediss://|DATABASE_PASSWORD=|REDIS_PASSWORD=)' .env > deployment-package/.env.template || true
          fi
          echo '{' > deployment-package/deployment-info.json
          echo '  "commit_sha": "'${{ github.sha }}'",' >> deployment-package/deployment-info.json
          echo '  "commit_message": "'$(git log -1 --pretty=%B | head -1)'",' >> deployment-package/deployment-info.json
          echo '  "branch": "'${{ github.ref_name }}'",' >> deployment-package/deployment-info.json
          echo '  "timestamp": "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'",' >> deployment-package/deployment-info.json
          echo '  "actor": "'${{ github.actor }}'",' >> deployment-package/deployment-info.json
          echo '  "run_id": "'${{ github.run_id }}'"' >> deployment-package/deployment-info.json
          echo '}' >> deployment-package/deployment-info.json
      - name: Upload deployment package
        if: steps.check_deployment.outputs.ready == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: deployment-package/
          retention-days: 30

  deploy:
    needs: [build]
    runs-on: ubuntu-latest
    if: needs.build.outputs.deployment_ready == 'true'
    environment: production
    steps:
      - name: Checkout code (for remote script)
        uses: actions/checkout@v4
      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package
          path: deployment-package/
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts
      - name: Generate production .env (sanitized) locally
        env:
          SECRET_KEY: ${{ secrets.SECRET_KEY }}
          ALLOWED_HOSTS: ${{ secrets.ALLOWED_HOSTS }}
          CSRF_TRUSTED_ORIGINS: ${{ secrets.CSRF_TRUSTED_ORIGINS }}
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          REDIS_URL: ${{ secrets.REDIS_URL }}
          CELERY_BROKER_URL: ${{ secrets.CELERY_BROKER_URL }}
          CELERY_RESULT_BACKEND: ${{ secrets.CELERY_RESULT_BACKEND }}
          CHANNEL_LAYERS_CONFIG_HOSTS: ${{ secrets.CHANNEL_LAYERS_CONFIG_HOSTS }}
          DEFAULT_FROM_EMAIL: ${{ secrets.DEFAULT_FROM_EMAIL }}
          SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
        run: |
          OUT=deployment-package/.env.generated
          : > "$OUT"
          echo "SECRET_KEY=$SECRET_KEY" >> "$OUT"
          echo "DJANGO_SETTINGS_MODULE=watchparty.settings.production" >> "$OUT"
          echo "ALLOWED_HOSTS=$ALLOWED_HOSTS" >> "$OUT"
          echo "CSRF_TRUSTED_ORIGINS=$CSRF_TRUSTED_ORIGINS" >> "$OUT"
          echo "DATABASE_URL=$DATABASE_URL" >> "$OUT"
          echo "REDIS_URL=$REDIS_URL" >> "$OUT"
          echo "CELERY_BROKER_URL=$CELERY_BROKER_URL" >> "$OUT"
          echo "CELERY_RESULT_BACKEND=$CELERY_RESULT_BACKEND" >> "$OUT"
          echo "CHANNEL_LAYERS_CONFIG_HOSTS=$CHANNEL_LAYERS_CONFIG_HOSTS" >> "$OUT"
          echo "DEFAULT_FROM_EMAIL=$DEFAULT_FROM_EMAIL" >> "$OUT"
          echo "SENTRY_DSN=$SENTRY_DSN" >> "$OUT"
          echo "ENVIRONMENT=production" >> "$OUT"
          echo "DEBUG=False" >> "$OUT"
          echo "RATE_LIMIT_ENABLED=True" >> "$OUT"
      - name: Prepare remote deploy script
        env:
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          cat > ci_remote_deploy.sh << 'SCRIPT'
          #!/bin/bash
          set -euo pipefail  # Strict error handling
          
          # Enable logging
          exec 1> >(tee -a /tmp/deployment.log)
          exec 2> >(tee -a /tmp/deployment.log >&2)
          
          DEPLOY_DIR="${DEPLOY_DIR:-/var/www/watch-party-backend}"
          SERVICE_USER="${SERVER_USER:-www-data}"
          
          echo "$(date): üîß Starting server environment setup..."
          echo "Deploy directory: $DEPLOY_DIR"
          echo "Service user: $SERVICE_USER"
          
          # Update system packages
          echo "$(date): üì¶ Detecting package manager..."
          if command -v apt-get >/dev/null 2>&1; then
            echo "Using apt-get (Debian/Ubuntu)"
            sudo apt-get update -qq || { echo "Failed to update packages"; exit 1; }
            INSTALLER="apt-get install -y"
          elif command -v yum >/dev/null 2>&1; then
            echo "Using yum (RHEL/CentOS)"
            sudo yum update -y -q || { echo "Failed to update packages"; exit 1; }
            INSTALLER="yum install -y"
          elif command -v dnf >/dev/null 2>&1; then
            echo "Using dnf (Fedora/RHEL 8+)"
            sudo dnf update -y -q || { echo "Failed to update packages"; exit 1; }
            INSTALLER="dnf install -y"
          else
            echo "‚ùå Unsupported package manager"
            exit 1
          fi
          
          # Install essential packages
          echo "üì¶ Installing essential packages..."
          if ! command -v python3 >/dev/null 2>&1; then
            echo "Installing Python 3..."
            sudo $INSTALLER python3 python3-pip python3-venv python3-dev
          fi
          
          if ! command -v nginx >/dev/null 2>&1; then
            echo "Installing Nginx..."
            sudo $INSTALLER nginx
          fi
          
            if ! command -v curl >/dev/null 2>&1; then
            echo "Installing curl..."
            sudo $INSTALLER curl
          fi
          
          if ! command -v git >/dev/null 2>&1; then
            echo "Installing git..."
            sudo $INSTALLER git
          fi
          
          if ! command -v rsync >/dev/null 2>&1; then
            echo "Installing rsync..."
            sudo $INSTALLER rsync
          fi
          
          # Install build essentials for Python packages
          if command -v apt-get >/dev/null 2>&1; then
            sudo $INSTALLER build-essential libpq-dev
          elif command -v yum >/dev/null 2>&1 || command -v dnf >/dev/null 2>&1; then
            sudo $INSTALLER gcc gcc-c++ make postgresql-devel
          fi
          
          # Create service user if it doesn't exist
          if ! id "$SERVICE_USER" >/dev/null 2>&1; then
            echo "Creating service user: $SERVICE_USER"
            sudo useradd -r -s /bin/false -d /var/www -c "Web Server User" $SERVICE_USER || true
          fi
          
          # Set up directory structure
          echo "üìÅ Setting up directory structure..."
          sudo mkdir -p "$DEPLOY_DIR"
          sudo mkdir -p /var/log/watchparty
          sudo chown -R $SERVICE_USER:www-data /var/log/watchparty || sudo chown -R $SERVICE_USER:$SERVICE_USER /var/log/watchparty
          # Ensure deploy can write; rsync will run with sudo anyway
          
          # Configure Nginx if not already configured
          if [[ ! -f /etc/nginx/sites-available/watchparty ]]; then
            echo "‚öôÔ∏è Configuring Nginx..."
            sudo tee /etc/nginx/sites-available/watchparty > /dev/null << 'NGINXCONF'
          server {
              listen 80;
              server_name _;
              
              client_max_body_size 100M;
              
              location /static/ {
                  alias /var/www/watch-party-backend/staticfiles/;
                  expires 30d;
                  add_header Cache-Control "public, immutable";
              }
              
              location /media/ {
                  alias /var/www/watch-party-backend/media/;
                  expires 30d;
                  add_header Cache-Control "public, immutable";
              }
              
              location / {
                  proxy_pass http://127.0.0.1:8000;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_connect_timeout 60s;
                  proxy_send_timeout 60s;
                  proxy_read_timeout 60s;
              }
          }
          NGINXCONF
            
            # Enable the site
            sudo ln -sf /etc/nginx/sites-available/watchparty /etc/nginx/sites-enabled/ || true
            sudo rm -f /etc/nginx/sites-enabled/default || true
            
            # Test and reload nginx
            sudo nginx -t && sudo systemctl reload nginx || echo "Nginx configuration needs manual review"
          fi
          
          # Start and enable nginx
          sudo systemctl enable nginx || true
          sudo systemctl start nginx || true
          
          echo "‚úÖ Server setup completed"
          
          mkdir -p "$DEPLOY_DIR"
          cd /tmp/watchparty-deploy
          echo "üì§ Syncing project files to $DEPLOY_DIR (with sudo & ownership fix)..."
          sudo rsync -av --delete --exclude='venv' --exclude='.env' --chown=$SERVICE_USER:www-data ./ "$DEPLOY_DIR/"
          
          if [[ -f ./.env.generated && ! -f "$DEPLOY_DIR/.env" ]]; then
            sudo mv ./.env.generated "$DEPLOY_DIR/.env"
            sudo chmod 600 "$DEPLOY_DIR/.env"
          fi
          
          cd "$DEPLOY_DIR"
          if [[ ! -d venv ]]; then sudo -u $SERVICE_USER python3 -m venv venv; fi
          source venv/bin/activate
          pip install --upgrade pip setuptools wheel
          pip install -r requirements.txt
          pip install gunicorn gevent
          python manage.py migrate --noinput || true
          python manage.py collectstatic --noinput || true
          
          # Ensure final ownership (in case virtualenv created as root)
          sudo chown -R $SERVICE_USER:www-data "$DEPLOY_DIR"
          
          if [[ ! -f /etc/systemd/system/watchparty-gunicorn.service ]]; then
            echo "‚öôÔ∏è Creating systemd service..."
            cat > /tmp/watchparty-gunicorn.service << EOF
          [Unit]
          Description=Watch Party Gunicorn Application Server
          After=network.target
          
          [Service]
          Type=notify
          User=$SERVICE_USER
          Group=www-data
          WorkingDirectory=$DEPLOY_DIR
          EnvironmentFile=$DEPLOY_DIR/.env
          ExecStart=$DEPLOY_DIR/venv/bin/gunicorn --bind 127.0.0.1:8000 --workers 3 --worker-class gevent --access-logfile /var/log/watchparty/access.log --error-logfile /var/log/watchparty/error.log watchparty.wsgi:application
          ExecReload=/bin/kill -s HUP \$MAINPID
          Restart=on-failure
          RestartSec=5
          KillMode=mixed
          TimeoutStopSec=5
          PrivateTmp=true
          
          [Install]
          WantedBy=multi-user.target
          EOF
            sudo mv /tmp/watchparty-gunicorn.service /etc/systemd/system/watchparty-gunicorn.service
            sudo systemctl daemon-reload
            sudo systemctl enable watchparty-gunicorn
          fi
          
          # Configure basic firewall if ufw is available
          if command -v ufw >/dev/null 2>&1; then
            echo "üî• Configuring firewall..."
            sudo ufw --force enable || true
            sudo ufw allow ssh || true
            sudo ufw allow 'Nginx Full' || true
            sudo ufw allow 80 || true
            sudo ufw allow 443 || true
          fi
          sudo systemctl restart watchparty-gunicorn || sudo systemctl start watchparty-gunicorn
          sleep 5
          
          echo "üè• Running health checks..."
          # Check if gunicorn is running
          if sudo systemctl is-active --quiet watchparty-gunicorn; then
            echo "‚úÖ Gunicorn service is running"
          else
            echo "‚ùå Gunicorn service failed to start"
            sudo systemctl status watchparty-gunicorn --no-pager -l || true
          fi
          
          # Check if nginx is running
          if sudo systemctl is-active --quiet nginx; then
            echo "‚úÖ Nginx service is running"
          else
            echo "‚ùå Nginx service is not running"
            sudo systemctl status nginx --no-pager -l || true
          fi
          
          # Test application health
          curl -f http://127.0.0.1:8000/health/ >/dev/null 2>&1 && echo "‚úÖ Application health check passed" || echo "‚ö†Ô∏è Application health check failed"
          
          # Test nginx proxy
          curl -f http://127.0.0.1/health/ >/dev/null 2>&1 && echo "‚úÖ Nginx proxy health check passed" || echo "‚ö†Ô∏è Nginx proxy health check failed"
          
          echo "üöÄ Deployment completed!"
          SCRIPT
          chmod +x ci_remote_deploy.sh
      - name: Deploy to server
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          PROJECT_DIR: ${{ secrets.PROJECT_DIR }}
        timeout-minutes: 30
        run: |
          FALLBACK_DIR="/var/www/watch-party-backend"
          TARGET_DIR="${PROJECT_DIR:-$FALLBACK_DIR}"
          
          echo "üöÄ Starting deployment to $SERVER_HOST..."
          echo "Target directory: $TARGET_DIR"
          
          # Test SSH connection first
          echo "üîó Testing SSH connection..."
          if ! ssh -o ConnectTimeout=10 -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "echo 'SSH connection successful'"; then
            echo "‚ùå SSH connection failed"
            exit 1
          fi
          
          # Clean up and prepare remote directory
          echo "üßπ Preparing remote directory..."
          ssh $SERVER_USER@$SERVER_HOST "rm -rf /tmp/watchparty-deploy && mkdir -p /tmp/watchparty-deploy"
          
          # Upload files with progress
          echo "üì§ Uploading deployment files..."
          scp -o StrictHostKeyChecking=no -r deployment-package/* $SERVER_USER@$SERVER_HOST:/tmp/watchparty-deploy/
          scp -o StrictHostKeyChecking=no ci_remote_deploy.sh $SERVER_USER@$SERVER_HOST:/tmp/watchparty-deploy/
          
          # Execute deployment with timeout
          echo "‚öôÔ∏è Executing remote deployment script..."
          ssh -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "cd /tmp/watchparty-deploy && timeout 1200 bash -x ./ci_remote_deploy.sh" || {
            echo "‚ùå Deployment script failed or timed out"
            echo "üîç Checking for any error logs..."
            ssh $SERVER_USER@$SERVER_HOST "tail -50 /var/log/watchparty/error.log 2>/dev/null || echo 'No error log found yet'"
            exit 1
          }
          
          echo "‚úÖ Remote deployment completed successfully"
      - name: Post-deployment verification
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
        run: |
          echo "üîç Running post-deployment verification..."
          
          # Wait a moment for services to stabilize
          sleep 10
          
          # Check service status
          echo "Checking systemd services..."
          ssh $SERVER_USER@$SERVER_HOST "
            echo '=== Gunicorn Service Status ==='
            sudo systemctl status watchparty-gunicorn --no-pager -l || true
            echo
            echo '=== Nginx Service Status ==='
            sudo systemctl status nginx --no-pager -l || true
            echo
            echo '=== Recent Logs ==='
            tail -20 /var/log/watchparty/error.log 2>/dev/null || echo 'No error log found'
          "
          
          # Test endpoints
          echo "Testing application endpoints..."
          if ssh $SERVER_USER@$SERVER_HOST "curl -f -m 10 http://127.0.0.1:8000/health/ >/dev/null 2>&1"; then
            echo "‚úÖ Direct application health check passed"
          else
            echo "‚ö†Ô∏è Direct application health check failed"
          fi
          
          if ssh $SERVER_USER@$SERVER_HOST "curl -f -m 10 http://127.0.0.1/health/ >/dev/null 2>&1"; then
            echo "‚úÖ Nginx proxy health check passed"
          else
            echo "‚ö†Ô∏è Nginx proxy health check failed"
          fi
      - name: Notify deployment status
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "‚úÖ Deployment completed successfully"
          else
            echo "‚ùå Deployment failed"
          fi
  cleanup:
    needs: [deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Cleanup
        run: |
          echo "Workflow finished for commit ${{ github.sha }}"
